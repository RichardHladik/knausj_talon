import math
import time

from talon import app, canvas, ctrl, noise, screen, tap, ui
from talon.api import ffi, lib
from talon.skia import Image
from talon.track.geom import Point2d
from talon.ui import Rect

from .eye_mouse import config as eye_config
from .eye_mouse import menu, mouse, sync_tracker, tracker

main_screen = ui.main_screen()


class config:
    screen_area = Point2d(400, 300)
    img_scale = 3
    img_alpha = 0.9
    eye_avg = 20
    double_click = 0.25
    frames = 10
    live = False  # FIXME: only works on mac for now, enable based on platform?


STATE_IDLE = 0
STATE_OVERLAY = 1


class ZoomMouse:
    auto_click_timeout = 1

    def __init__(self):
        self.state = STATE_IDLE
        self.img = None
        self.handle_size = Point2d(0, 0)
        self.last_click = 0
        self.enabled = False
        self.rect = None
        self.canvas = None
        self.auto_click_enabled = False
        self.click_count = 1

    def enable(self):
        if self.enabled:
            return
        noise.register("pop", self.on_pop)
        tap.register(tap.MCLICK | tap.KEY | tap.HOOK, self.on_key)
        # app.register('overlay', self.draw_gaze)
        self.enabled = True

    def disable(self):
        if not self.enabled:
            return
        noise.unregister("pop", self.on_pop)
        tap.unregister(tap.MCLICK | tap.KEY | tap.HOOK, self.on_key)
        # app.unregister('overlay', self.draw_gaze)
        self.enabled = False
        if self.canvas:
            self.canvas.unregister("draw", self.draw)
            self.canvas.close()
            self.canvas = None

    def toggle_auto_click(self):
        """timeout is time and seconds"""
        self.auto_click_enabled = not self.auto_click_enabled
        self.auto_click_timeout = self.auto_click_timeout

    def on_key(self, e):
        if self.state == STATE_OVERLAY:
            if e.type == tap.MCLICK:
                self.cancel()
            elif e.type == tap.KEY and e == "esc" and e.down and not e.repeat:
                self.cancel()
                e.block()

    def capture(self):
        try:
            self.canvas.allows_capture = False
            self.img = screen.capture(*self.rect)
            self.canvas.allows_capture = True
        except AttributeError:
            pass

    def cancel(self):
        self.state = STATE_IDLE
        ctrl.cursor_visible(True)
        self.canvas.unregister("draw", self.draw)
        self.canvas.close()
        self.canvas = None

    def on_pop(self, state, count=1, auto=False):
        if len(mouse.eye_hist) < 2:
            return
        now = time.time()
        if self.state == STATE_IDLE:
            if now - self.last_click < config.double_click:
                ctrl.mouse_click(hold=32000)
                return

            l, r = mouse.eye_hist[-1]
            p = (l.gaze + r.gaze) / 2
            main_gaze = -0.02 < p.x < 1.02 and -0.02 < p.y < 1.02 and bool(l or r)
            if not main_gaze:
                pass  # return

            ctrl.cursor_visible(False)

            self.gaze = eye_config.size_px * p
            capture = self.gaze - (config.screen_area / 2)
            capture.x = min(max(capture.x, 0), main_screen.width - config.screen_area.x)
            capture.y = min(
                max(capture.y, 0), main_screen.height - config.screen_area.y
            )
            self.rect = (
                capture.x,
                capture.y,
                config.screen_area.x,
                config.screen_area.y,
            )
            self.pos = self.gaze - (config.screen_area * config.img_scale) / 2
            self.pos.x = min(
                max(self.pos.x, 0),
                main_screen.width - config.screen_area.x * config.img_scale,
            )
            self.pos.y = min(
                max(self.pos.y, 0),
                main_screen.height - config.screen_area.y * config.img_scale,
            )
            self.size = Point2d(
                config.screen_area.x * config.img_scale,
                config.screen_area.y * config.img_scale,
            )
            self.off = Point2d(0, 0)

            self.frame = 0
            self.canvas = canvas.Canvas(
                self.pos.x, self.pos.y, self.size.x, self.size.y
            )
            if not config.live:
                self.capture()
            self.canvas.register("draw", self.draw)

            self.click_count = count
            if self.auto_click_enabled or auto:
                time.sleep(self.auto_click_timeout)
                self.overlay_click()
            else:
                self.state = STATE_OVERLAY
        elif self.state == STATE_OVERLAY:
            self.overlay_click()

    def overlay_click(self):
        self.cancel()
        dot, origin = self.get_pos()
        if origin:
            ctrl.mouse_move(origin.x, origin.y)
            for i in range(self.click_count):
                ctrl.mouse_click(hold=32000)
            self.click_count = 1
            self.last_click = time.time()
        else:
            print("no origin")

    def get_pos(self):
        dot = Point2d(0, 0)
        hist = mouse.eye_hist[-config.eye_avg :]
        for l, r in hist:
            dot += (l.gaze + r.gaze) / 2
        dot /= len(hist)
        dot *= Point2d(main_screen.width, main_screen.height)

        off = dot - (self.pos - self.off)
        origin = self.img.rect.pos + off / config.img_scale
        if self.img.rect.contains(origin.x, origin.y):
            return dot, origin
        return None, None

    def draw(self, canvas):
        if not self.canvas:
            return False
        if config.live and self.rect:
            self.capture()
        self.frame += 1
        if self.frame < config.frames:
            t = ((self.frame + 1) / config.frames) ** 2

            anim_pos_from = Point2d(self.rect[0], self.rect[1])
            anim_pos_to = Point2d(canvas.x, canvas.y)
            anim_size_from = config.screen_area
            anim_size_to = Point2d(canvas.width, canvas.height)

            pos = anim_pos_from + (anim_pos_to - anim_pos_from) * t
            size = anim_size_from + (anim_size_to - anim_size_from) * t

            dst = Rect(pos.x, pos.y, size.x, size.y)
        elif self.frame == config.frames:
            self.canvas.panel = True
            dst = Rect(canvas.x, canvas.y, canvas.width, canvas.height)
        else:
            dst = Rect(canvas.x, canvas.y, canvas.width, canvas.height)
        if not self.img:
            return
        src = Rect(0, 0, self.img.width, self.img.height)
        canvas.draw_image_rect(self.img, src, dst)

        dot, origin = self.get_pos()
        if not dot:
            return
        paint = canvas.paint
        paint.style = paint.Style.FILL
        paint.color = "ffffff"
        canvas.draw_circle(dot.x, dot.y, config.img_scale + 1)
        # canvas.draw_circle(origin.x, origin.y, 2)
        paint.color = "000000"
        canvas.draw_circle(dot.x, dot.y, config.img_scale)
        # canvas.draw_circle(origin.x, origin.y, 1)
        ctrl.mouse_move(origin.x, origin.y)


zoom_mouse = ZoomMouse()


def on_screen_change(screens):
    global main_screen
    main_screen = ui.main_screen()
    if zoom_mouse.enabled and zoom_mouse.state != STATE_IDLE:
        zoom_mouse.disable()
        zoom_mouse.enable()


ui.register("screen_change", on_screen_change)


def toggle_zoom_mouse(state):
    if state:
        zoom_mouse.enable()
    else:
        zoom_mouse.disable()
    sync_tracker()


active = menu.toggle("Control Mouse (Zoom)", weight=2, cb=toggle_zoom_mouse)
